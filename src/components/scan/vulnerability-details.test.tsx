
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { VulnerabilityDetails } from './vulnerability-details';
import { explainVulnerability } from '@/ai/flows/explain-vulnerability';
import { suggestFixes } from '@/ai/flows/suggest-fixes';
import { marked } from 'marked';
import { Vulnerability } from '@/lib/definitions';
import React from 'react';

// Mock dependencies
jest.mock('@/ai/flows/explain-vulnerability', () => ({
  explainVulnerability: jest.fn(),
}));
jest.mock('@/ai/flows/suggest-fixes', () => ({
  suggestFixes: jest.fn(),
}));
jest.mock('marked', () => ({
  marked: jest.fn((text) => text), // Simple mock that returns the text as is
}));

// Mock the Accordion component to simplify testing
jest.mock('@/components/ui/accordion', () => ({
  Accordion: ({ children }: { children: React.ReactNode }) => <div data-testid="accordion">{children}</div>,
  AccordionItem: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  AccordionTrigger: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  AccordionContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
}));

// Mock lucide-react icons
jest.mock('lucide-react', () => ({
  ShieldAlert: () => 'ShieldAlertIcon',
  ShieldCheck: () => 'ShieldCheckIcon',
  ShieldHalf: () => 'ShieldHalfIcon',
  ShieldQuestion: () => 'ShieldQuestionIcon',
  Sparkles: () => 'SparklesIcon',
  Loader2: () => 'Loader2Icon',
}));


const mockVulnerabilities: Vulnerability[] = [
  { id: '1', name: 'SQL Injection', description: 'A serious vulnerability.', severity: 'High', remediation: '' },
  { id: '2', name: 'XSS', description: 'Another serious vulnerability.', severity: 'Medium', remediation: '' },
];

describe('VulnerabilityDetails', () => {
  beforeEach(() => {
    (explainVulnerability as jest.Mock).mockResolvedValue({ explanation: 'AI explanation' });
    (suggestFixes as jest.Mock).mockResolvedValue({ suggestedFixes: 'AI fixes' });
    jest.clearAllMocks();
  });

  it('should render the list of vulnerabilities', () => {
    render(<VulnerabilityDetails vulnerabilities={mockVulnerabilities} scanOutput="" />);
    expect(screen.getByText('SQL Injection')).toBeInTheDocument();
    expect(screen.getByText('XSS')).toBeInTheDocument();
  });

  it('should generate and display AI content on button click', async () => {
    render(<VulnerabilityDetails vulnerabilities={[mockVulnerabilities[0]]} scanOutput="scan output" />);

    const generateButton = screen.getByRole('button', { name: /Generate Fixes/i });

    // Use act to wrap all interactions and state updates
    await act(async () => {
      fireEvent.click(generateButton);
      // Allow promises to resolve
      await new Promise(resolve => setTimeout(resolve, 0));
    });

    // Check that AI functions were called
    expect(explainVulnerability).toHaveBeenCalled();
    expect(suggestFixes).toHaveBeenCalled();

    // Use findBy to wait for the AI content to appear
    expect(await screen.findByText('AI explanation')).toBeInTheDocument();
    expect(await screen.findByText('AI fixes')).toBeInTheDocument();

    // Check that the button is no longer disabled
    expect(generateButton).not.toBeDisabled();
  });
});
